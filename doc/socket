
namespace ascs
{

template<typename Socket, typename Packer, typename Unpacker, typename InMsgType, typename OutMsgType,
	template<typename, typename> class InQueue, template<typename> class InContainer,
	template<typename, typename> class OutQueue, template<typename> class OutContainer>
class socket: public timer
{
protected:
	socket(asio::io_service& io_service_);
	template<typename Arg>
	socket(asio::io_service& io_service_, Arg& arg);
ssl使用。

	void first_init();
构造时调用，仅仅是为了节省代码量而已，因为我们有两个构造函数都将调用它。

	void reset();
被重用是调用。

	void clear_buffer();
清空所有buffer。

public:
	typedef obj_with_begin_time<InMsgType> in_msg;
	typedef obj_with_begin_time<OutMsgType> out_msg;
	typedef InContainer<in_msg> in_container_type;
	typedef OutContainer<out_msg> out_container_type;
	typedef InQueue<in_msg, in_container_type> in_queue_type;
	typedef OutQueue<out_msg, out_container_type> out_queue_type;

	uint_fast64_t id() const;
	bool is_equal_to(uint_fast64_t id) const;
获取id。

	Socket& next_layer();
	const Socket& next_layer() const;
	typename Socket::lowest_layer_type& lowest_layer();
	const typename Socket::lowest_layer_type& lowest_layer() const;
底层对象，它应该是一个asio::ip::tcp::socket，asio::ip::udp::socket或者
asio::ssl::stream<asio::ip::tcp::socket>对象及其从它们继承的对象。
最底层对象其实就是调用底层对象的lowest_layer()，我们真正要读写的其实就是最底层对象。

	virtual bool obsoleted();
判断本对象是否可以被重用或者被释放。

	virtual bool is_ready() = 0;
是否可以开始发送和接收数据。

	virtual void send_heartbeat() = 0;
发送心跳包，由子类实现。

	bool started() const;
是否已经开始，已经开始意思是已经调用过start()了，多次调用start()会有严重的包乱顺问题，好在我在某个版本
增加了防止多次调用start()的功能，之前靠用户保证，现在ascs库可以保证，即使用户多次调用也没问题。

	void start();
开始，开始的动作由子类实现，本函数只是简单的判断start是否已经被调用过了，如果没有，则调用do_start函数（纯虚）。

	bool send_msg();
发送缓存里面的消息，如果当前已经在发送消息了，则调用本函数无任何作用。
socket内部有消息发送缓存，当连接未建立的时候，用户仍然可以发送消息（注意缓存满问题），这些消息会缓存起来，
当连接建立之后，会自动开始真正的发送消息，这个功能就是调用这个函数实现的。

	void start_heartbeat(int interval, int max_absence = ASCS_HEARTBEAT_MAX_ABSENCE);
开始定时发检测和送心跳包（未超时时）。

	bool check_heartbeat(int interval, int max_absence = ASCS_HEARTBEAT_MAX_ABSENCE);
检测心跳包，如果未超时的话将发送一个心跳包。

	bool is_sending_msg() const;
是否正在发送数据。

#ifdef ASCS_PASSIVE_RECV
	bool is_reading() const;
#endif
是否正在接收数据，如果未定义ASCS_PASSIVE_RECV宏，则总是处于接收数据的状态。

	bool is_dispatching_msg() const;
是否正在派发数据。

	bool is_recv_idle() const;
是否暂停了消息接收，因为接收缓存满（等到缓存可用时自动恢复）。

	void msg_resuming_interval(size_t interval);
	size_t msg_resuming_interval() const;
接收缓存满时，重复检查间隔。

	void msg_handling_interval(size_t interval);
	size_t msg_handling_interval() const;
on_msg_handle返回false或者0时，延时多久重复派发消息。

	const struct statistic& get_statistic() const;
综合统计信息。
	
	std::shared_ptr<i_packer<typename Packer::msg_type>> packer();
	std::shared_ptr<const i_packer<typename Packer::msg_type>> packer() const;

	void packer(const std::shared_ptr<i_packer<typename Packer::msg_type>>& _packer_);
获取／修改打包器。
注意，运行时修改打包器是非线程安全的，它会与消息发送冲突，由于消息发送和打包器修改都是使用者触发的，所以如果有资源竞争，使用者
有义务解决冲突问题。不支持多线程一是为了效率，二是这个功能用得很少。

	bool is_send_buffer_available();
判断消息发送缓存是否可用，即里面的消息数量是否小于ASCS_MAX_MSG_NUM条，如果以can_overflow为true调用任何消息发送函数（如send_msg），
将马上成功而无论消息发送缓存是否可用，所以可能会造成消息发送缓存大小不可控。

	bool is_recv_buffer_available() const;
接收缓存是否可用，即里面的消息数量是否小于ASCS_MAX_MSG_NUM条。

	bool direct_send_msg(const InMsgType& msg, bool can_overflow = false);
	bool direct_send_msg(InMsgType&& msg, bool can_overflow = false);
直接发送消息（放入消息发送缓存）而不再调用i_packer::pack_msg函数，其实socket内部在发送消息时也是调用这个函数，只是在调用
之前先调用了i_packer::pack_msg而已。

	size_t get_pending_send_msg_num();
	size_t get_pending_recv_msg_num();
获取缓存里面的消息数量，其中post和send缓存里面的消息是打包过的；recv缓存里面的消息是解包过后的，下同。

	void pop_first_pending_send_msg(in_msg& msg);
	void pop_first_pending_recv_msg(out_msg& msg);
弹出缓存中第一个包，如果得到一个空包（msg.empty()等于true），则说明缓存里面没有消息。

	void pop_all_pending_send_msg(in_container_type& msg_list);
	void pop_all_pending_recv_msg(out_container_type& msg_list);
弹出缓存中所有包，相当于清空了缓存。

protected:
	virtual bool do_start() = 0;
子类重写，请看tcp:server_socket_base、tcp::client_socket_base、udp::socket_base、ssl::server_socket_base和ssl::client_socket_base的实现。

	virtual void on_send_error(const error_code& ec);
	virtual void on_recv_error(const asio::error_code& ec) = 0;
发送接收失败时回调，对于tcp::socket，如果需要连接断开事件，建议重写on_recv_error。

	virtual bool on_heartbeat_error() = 0;
心跳包超时时回调。

	virtual void on_close();
当对象真正被close之前，会调用这个回调，用户可以在这里面释放资源，在这之后，对象可能会被重用或者被释放。

	virtual void after_close();
重写这个函数的最好的例子就是客户端做重连接。

#ifdef ASCS_DISPATCH_BATCH_MSG
	virtual size_t on_msg_handle(out_queue_type& can);
#else
	virtual bool on_msg_handle(OutMsgType& msg, bool link_down);
#endif
从接收缓存派发一条（或者所有）消息，返回true（或者大于0）表示消息被成功处理，返回false（或者0）表示消息无法立即处理，于是将暂停一小段时间之后继续重试（异步）。
如果派发所有消息，用户需要把处理过的消息从queue里面弹出来，剩下的将继承在下次on_msg_handle里面派发。

#ifdef ASCS_WANT_MSG_SEND_NOTIFY
	virtual void on_msg_send(InMsgType& msg);
成功发送（消息写入底层socket缓存）一个消息之后回调，消息是打包过后的。
#endif

#ifdef ASCS_WANT_ALL_MSG_SEND_NOTIFY
	virtual void on_all_msg_send(InMsgType& msg);
当发送缓存由非空变为空的时候回调，消息是打包过后的。
#endif

	void close();
开启close流程，由继承者调用。ascs::socket会定时检测自己是否可以安全的被重用或被释放（即所有异步调用都已结束，包括正常结束和非正常结束），
如果是，调用上面的on_close()， 然后object_pool将完全接管这个socket，以便在适当的时候重用或者释放它。
如果定义了ASCS_DELAY_CLOSE宏且其值等于0，则socket将保证以上说的行为，如果没有定义，则简单地在ASCS_DELAY_CLOSE秒后，调用on_close()，
然后同样的道理，object_pool将完全接管这个socket，以便在适当的时候重用或者释放它。

	template<typename T> bool handle_msg(T& temp_msg_can);
子类收到消息之后，调用这个函数来派发消息，它会把消息放入消息接收缓存，然后调用dispatch_msg。

	bool do_direct_send_msg(InMsgType&& msg);
将消息插入容器，内部使用。

private:
	virtual void recv_msg() = 0;
	virtual void send_msg() = 0;
收发消息，子类实现。

	template<typename Object> friend class object_pool;
	void id(uint_fast64_t id);
设置id，注意使用者不可设置id，只有socket的创建者（object_pool或者其继承者）才可设置id，除非这个socket没有被任何对象池管理。

bool check_receiving(bool raise_recv);
辅助函数，如果接收缓存可用返回true（调用recv_msg如果raise_recv为true），否则返回false并记录暂停消息接收时间。

	void dispatch_msg();
派发消息，post一个异步调用到do_dispatch_msg。

	void do_dispatch_msg();
调用on_msg_handle函数派发消息。

	bool timer_handler(tid id);
处理所有定时器

private:
	template<typename Object> friend class object_pool;
	void id(uint_fast64_t id) {_id = id;}
设置id，只有object_pool可以调用。

	bool timer_handler(tid id);
定时器回调函数。

	void msg_handler();
异步派发接收缓存里面的消息时，asio调用本函数，在这个函数里面将调用on_msg_handle，然后调用do_dispatch_msg或者dispatch_msg继续派发消息。

protected:
	std::shared_ptr<i_packer<typename Packer::msg_type>> packer_;
打包器。

	volatile bool sending;
	in_queue_type send_msg_buffer;

#ifdef ASCS_PASSIVE_RECV
	volatile bool reading;
#endif

	struct statistic stat;

private:
	uint_fast64_t _id;
保存在对象池中时，作为key，所以必须唯一，对象池用hash作为容器以快速查找

	Socket next_layer_;
前面在next_layer里面解释过了。

	volatile bool started_; //has started or not
	std::atomic_flag start_atomic;
是否已经开始，开始的概念由子类具体实现，socket只是记录是否已经调用过start函数而已。

#ifndef ASCS_DISPATCH_BATCH_MSG
	out_msg last_dispatch_msg;
#endif
由于是异步派发消息，这个成员变量保证其在异步处理过程中的有效性。

	out_queue_type recv_msg_buffer;
	typename statistic::stat_time recv_idle_begin_time;
	bool recv_idle_began;
时间消耗统计。

	volatile bool dispatching;
	asio::io_context::strand strand;

	size_t msg_resuming_interval_, msg_handling_interval_;
};

} //namespace

